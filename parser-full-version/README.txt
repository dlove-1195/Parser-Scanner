Wenzhuo Wang
parser.h
I just added the all the other features needed (the structure of function nodes, functions of function handling) into the parser.h. It uses a frame_node to represent stack. Each time a function is called, it will create a new node and add it on the stack linked list. The variable name and the value will be copied to the stacked. When the function finishes running, the values on the stack will be copied back to the actual parameter. When the whole program finished running, A while loop will clean all the stack nodes. 
The parser, printer, and executor are wrriten in one file. Just use gcc main.c to compile it. I used several global variables which are owned by the program, like variable for file name and file stream, variable for the begining of the id node. This eliminates the need for passing additional parameters through functions.
Description of design: When constructing the parse tree, you have to peel off non-terminals over and over again until you reach the bottom (terminals). Sturcture is used to represent every non-terminal, and the smaller parts of the nonterminal are represented as either pointer to another node(non-terminal) or a sepecific data type(terminal). The del_seq and stmt_seq are like linked-list, where each node has one value and one pointer pointing to the next node. The list is constructed by recersively calling the funtion. For example, the program is split into dsn and ssn in the program function, and dsn and ssn will be split further in their own funtions until reaching the bottom. This peeling-off process is went through by each function in the main: first contructing the tree, second printing the whole tree, next executing the tree, finally deleting the allocated memory of each tree node. The executing process is basically giving nodes integer value in order from bottom to top. The scanner is already provided. The interpreter just received the tokens from scanners and interpret them to construct the parse tree.
I just used gdb to test my program.
